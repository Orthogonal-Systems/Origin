#!/usr/bin/env python

import sys
import os
fullBinPath=os.path.abspath(os.getcwd() + "/" + sys.argv[0])
fullLibPath=os.path.abspath(os.path.dirname(os.path.dirname(fullBinPath))+"/lib")
sys.path.append(fullLibPath)
import time

import random
import calendar
import time
import sys
import ctypes
import struct
import json # temp

import origin
if len(sys.argv) > 1:
  configBundle = sys.argv[1]
  origin.configure(configBundle)
else:
  origin.configure("site")


from origin.client import float_field
from origin.client import integer_field
from origin.client import string_field
from origin.client import monitoring_record
from origin.client import server
from origin.client import server_connection
from origin.client import current_time

# just a proxy for actually doing something useful
def makeTempMeasurement():
    return random.randint(0,(2**31)-1) # int32

def makeTempMeasurementFloat():
    return random.random()

# something that represents the connection to the server
# might need arguments.... idk
serv = server()

streamName = "toy_bin"

# alert the server that we are going to be sending this type of data
connection = serv.registerStream(
    stream=streamName,
    records={
        "toy1":integer_field,
        "toy2":float_field,
        })

numEntries = 2

# perhaps print some useful message. Perhaps try to reconnect....
# print "problem establishing connection to server..."
# sys.exit(1)

header = json.dumps((streamName,))
print header
fstr = "!" # network byte order
if "timestamp_type" in origin.config:
    if origin.config["timestamp_type"] == "uint64":
        print("using 64b timestamps")
        tsSize = 8
        fstr += "Q" # unsigned long long
else:
    tsSize = 4
    fstr += "I" # unsigned long

msg = ctypes.create_string_buffer(header, len(header)+ tsSize +(numEntries)*4 ) # ints are 4 bytes

print list(msg)

# This might need to be more complicated, but you get the gist. Keep sending records forever    
time.sleep(2)


while True:
    print "sending...."
    #connection.send(recordTime=current_time(),toy1=makeTempMeasurement(),toy2=makeTempMeasurement())
    data = [current_time(), makeTempMeasurement(), makeTempMeasurementFloat()]
    struct.pack_into( fstr+"if", msg, len(header), *data ) # format string says network order int (size 4)
    print( ", ".join(map(str, data)) )
    print list(msg)
    connection.socket.send(msg)
    time.sleep(5)
